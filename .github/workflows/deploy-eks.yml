name: Deploy to AWS EKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - demo
        - prod

env:
  HELM_CHART_PATH: ./deployment/helm-chart
  AWS_DEV_IAM_ROLE: ${{ secrets.AWS_DEV_IAM_ROLE }}
  AWS_STAGING_IAM_ROLE: ${{ secrets.AWS_STAGING_IAM_ROLE }}
  AWS_PROD_IAM_ROLE: ${{ secrets.AWS_PROD_IAM_ROLE }}

jobs:
  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    
    # Set environment based on branch or manual input
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set AWS_ROLE_TO_ASSUME_ARN
      id: set-role
      run: |
        case "${{ github.event.inputs.environment }}" in
          dev)
            echo "AWS_ROLE_TO_ASSUME_ARN=${AWS_DEV_IAM_ROLE}" >> $GITHUB_ENV
            ;;
          staging)
            echo "AWS_ROLE_TO_ASSUME_ARN=${AWS_STAGING_IAM_ROLE}" >> $GITHUB_ENV
            ;;
          demo)
            echo "AWS_ROLE_TO_ASSUME_ARN=${AWS_STAGING_IAM_ROLE}" >> $GITHUB_ENV
            ;;
          prod)
            echo "AWS_ROLE_TO_ASSUME_ARN=${AWS_PROD_IAM_ROLE}" >> $GITHUB_ENV
            ;;
        esac

    - name: Debug AWS Role
      run: echo "Using role: $AWS_ROLE_TO_ASSUME_ARN"
      
    # - name: configure aws credentials - ECR
    #   uses: aws-actions/configure-aws-credentials@v1.7.0
    #   with:
    #     role-to-assume:  ${{ secrets.AWS_OPS_IAM_ROLE_ARN }}
    #     role-session-name: GitHub_to_AWS_via_FederatedOIDC
    #     aws-region: 'ap-southeast-2' # replace to github variables later on
        
    # - name: Login to Amazon ECR
    #   id: login-ecr
    #   uses: aws-actions/amazon-ecr-login@aaf69d68aa3fb14c1d5a6be9ac61fe15b48453a2

    # - uses: int128/create-ecr-repository-action@v1
    #   id: ecr-eos-browserless
    #   with:
    #     repository: eos-browserless
    #     repository-policy: .github/ecr-repository-policy.json

    # - name: Install kubectl
    #   uses: azure/setup-kubectl@v3
    #   with:
    #     version: 'v1.28.0'
        
    # - name: Install Helm
    #   uses: azure/setup-helm@v3
    #   with:
    #     version: '3.12.0'

    # - name: configure aws credentials
    #   uses: aws-actions/configure-aws-credentials@v1.7.0
    #   with:
    #     role-to-assume:  ${{ secrets.AWS_ROLE_TO_ASSUME_ARN }}
    #     role-session-name: GitHub_to_AWS_via_FederatedOIDC
    #     aws-region: 'ap-southeast-2' # replace to github variables later on
        
    # - name: Configure K8S access
    #   run: |
    #     aws eks update-kubeconfig \
    #       --name ${{ vars.K8S_CLUSTER }} \
    #       --region ${{ secrets.AWS_REGION }}
          
    # - name: Verify cluster access
    #   run: |
    #     kubectl cluster-info
    #     kubectl get nodes
        
    # - name: Lint Helm chart
    #   run: |
    #     helm lint ${{ env.HELM_CHART_PATH }}
        
    # - name: Dry run Helm deployment
    #   run: |
    #     NAMESPACE="${{ github.event.inputs.environment }}"
    #     RELEASE_NAME="${{ github.event.inputs.environment }}"
        
    #     helm upgrade --install $RELEASE_NAME ${{ env.HELM_CHART_PATH }} \
    #       --namespace $NAMESPACE \
    #       --create-namespace \
    #       --dry-run \
    #       --debug \
    #       --set image.tag="${{ github.sha }}" \
    #       --set replicaCount="${{ vars.REPLICA_COUNT || '2' }}" \
    #       --set resources.requests.cpu="${{ vars.CPU_REQUEST || '500m' }}" \
    #       --set resources.requests.memory="${{ vars.MEMORY_REQUEST || '1Gi' }}" \
    #       --set resources.limits.cpu="${{ vars.CPU_LIMIT || '1000m' }}" \
    #       --set resources.limits.memory="${{ vars.MEMORY_LIMIT || '2Gi' }}" \
    #       --set browserless.token="${{ secrets.BROWSERLESS_TOKEN }}" \
    #       --set autoscaling.enabled="${{ vars.AUTOSCALING_ENABLED || 'true' }}" \
    #       --set autoscaling.minReplicas="${{ vars.MIN_REPLICAS || '2' }}" \
    #       --set autoscaling.maxReplicas="${{ vars.MAX_REPLICAS || '10' }}"
          
    # - name: Deploy to EKS
    #   run: |
    #     NAMESPACE="${{ github.event.inputs.environment }}"
    #     RELEASE_NAME="${{ github.event.inputs.environment }}"
        
    #     helm upgrade --install $RELEASE_NAME ${{ env.HELM_CHART_PATH }} \
    #       --namespace $NAMESPACE \
    #       --create-namespace \
    #       --wait \
    #       --timeout 10m \
    #       --set image.tag="${{ github.sha }}" \
    #       --set replicaCount="${{ vars.REPLICA_COUNT || '2' }}" \
    #       --set resources.requests.cpu="${{ vars.CPU_REQUEST || '500m' }}" \
    #       --set resources.requests.memory="${{ vars.MEMORY_REQUEST || '1Gi' }}" \
    #       --set resources.limits.cpu="${{ vars.CPU_LIMIT || '1000m' }}" \
    #       --set resources.limits.memory="${{ vars.MEMORY_LIMIT || '2Gi' }}" \
    #       --set browserless.token="${{ secrets.BROWSERLESS_TOKEN }}" \
    #       --set autoscaling.enabled="${{ vars.AUTOSCALING_ENABLED || 'true' }}" \
    #       --set autoscaling.minReplicas="${{ vars.MIN_REPLICAS || '2' }}" \
    #       --set autoscaling.maxReplicas="${{ vars.MAX_REPLICAS || '10' }}"
          
    # - name: Verify deployment
    #   run: |
    #     NAMESPACE="${{ github.event.inputs.environment }}"
    #     RELEASE_NAME="${{ github.event.inputs.environment }}"
        
    #     # Check deployment status
    #     kubectl get deployments -n $NAMESPACE
    #     kubectl get pods -n $NAMESPACE
    #     kubectl get services -n $NAMESPACE
    #     kubectl get hpa -n $NAMESPACE
        
    #     # Check Helm release status
    #     helm status $RELEASE_NAME -n $NAMESPACE
        
    #     # Wait for pods to be ready
    #     kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=browserless -n $NAMESPACE --timeout=300s
        
    # - name: Run health check
    #   run: |
    #     NAMESPACE="${{ github.event.inputs.environment }}"
    #     SERVICE_NAME="${{ github.event.inputs.environment }}"
        
    #     # Port forward to test the service
    #     kubectl port-forward svc/$SERVICE_NAME 3000:3000 -n $NAMESPACE &
    #     PF_PID=$!
        
    #     # Wait for port forward to be ready
    #     sleep 10
        
    #     # Health check
    #     if curl -f http://localhost:3000/pressure; then
    #       echo "Health check passed"
    #     else
    #       echo "Health check failed"
    #       exit 1
    #     fi
        
    #     # Clean up port forward
    #     kill $PF_PID